/*
1. Realize o método estático
public static int removeOdd(int[] v, int count);
Este método retira os inteiros ímpares da sequência representada pelos primeiros count inteiros do array v. A
sequência resultante fica contida de forma contígua nas primeiras posições do array v. O valor retornado pelo
método é a dimensão da sequência resultante.
*/

  /**
   *Solução 1:
   *Remove os inteiros nos "count" primeiros termos e retorna o numero de elementos
   *que ficaram nos "dim" primeiras posições.
   * 
   *Trabalha no Dominío 0->count.   
   */ 

    	public static int removeOdd(int[] v, int count){
    		int dim=0;
    		for (int idx=0;idx<count;idx++)
    	        if (v[idx]%2 == 0) v[dim++]=v[idx];
    		return dim;
    	}

  /**
   *Solução 2:
   *Remove os inteiros nos "count" primeiros termos e retorna o numero de elementos
   *validos no vector "v".
   *Trabalha no Dominio 0->tamanho do array.
   *As chavetas no if (idx<count) são necessários para o segundo "if" não assumir
   *que o else lhe diz respeito.            
   */ 
	public static int removeOdd(int[] v, int count){
		int dim=0;
		for (int idx=0;idx<v.length;idx++){
			if (idx<count){
				if (v[idx]%2 == 0) v[dim++]=v[idx];
			}else{
				v[dim++]=v[idx];
			}
		}
		return dim;
	}
/*
2. Realize o metodo estatico
public int countEqualTo(int[] v, int l, int r, int a)
que retorna o numero de ocorrencias do inteiro a no subarray(v; l; r), que esta ordenado de forma crescente. O
custo assimptotico deve ser O(logN), onde N e a dimensão do subarray.
Tenha em consideração que o numero de ocorrencias pertence a O(N).
*/

    /**
     *Solução 1:
     *
     */              
    
        /**
         *Método auxiliar que retorna o indicie da primeira ocorrência de 'a', ou
         *-1 caso não haja nenhuma ocorrencia.
         */                          
    	public static int getFirstOccurrence(int[] v, int l, int r, int a){
    		int mid=0;
    		int val=-1;
    		while(l<r){
    			mid = (l+r)/2;
    			if (v[mid] < a){
    				l=mid+1;
    				if (v[l] == a) val=l;
    			}else{
    				r=mid-1;
    				if (v[r] == a)val=r;
    			}
    		}
    		return val;
    	}
        /**
         *Método que retorna o numero de ocorrencias do valor 'a', caso haja.
         *Utiliza o metodo auxiliar  getFirstOccurrence(...).        
         */                 
    	public static int countEqualTo(int[] v, int l, int r, int a){
    		int count=0;
    		int first=getFirstOccurrence(v, l, r, a);
    		if (first == -1 ) return count;
    		while (first<=r && v[first++] == a  ){
    			count++;
    		}
    		return count;
    	}
/*
3. Realize o metodo estatico
public static boolean isMaximumSubArrayGivenIndex(int[] v, int l, int r, int i)
que retorna true se e são se l <= i <= r e a soma dos elementos do subarray (v; l; r) tiver o maior valor possivel
para a soma de qualquer subarray de v contendo o indice i.


Pessoalmente não gosto desta implementação.
*/




	public static boolean isMaximumSubArrayGivenIndex(int[] v, int l, int r, int i){
		int value=0;
		int count=0;
		
		if (l>r || i>r || i<l) return false;
		
		/*ciclo com dois propositos:
		 * 1- calcular o valor total da soma do conteudo dos indicies
		 * 2- excluir essa hipotese na verificação de todas as outras.
		 * */
		for (int idx= l;idx<=r;idx++)
				value+=v[idx];
		/*
		 *Ciclo de Hipoteses à esquerda 
		 */
		for (int idx=l+1;idx<=i;idx++){
			count=0;
			for (int jdx=idx;jdx<=r;jdx++){
				count+=v[jdx];
			}
			if (count > value) return false;
		}
		/*
		 *Ciclo de Hipoteses à direita 
		 */
		for (int idx=r;idx>=i;idx--){
			count=0;
			for (int jdx=idx;jdx>=l;jdx--){
				count+=v[jdx];
			}
			if (count > value) return false;
		}		
		return true;
	}
